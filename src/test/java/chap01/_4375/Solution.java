package chap01._4375;

import org.junit.jupiter.api.Test;

/**
 * [문제]
 * 2와 5로 나누어 떨어지지 않는 정수 n(1 ≤ n ≤ 10000)가 주어졌을 때, 1로만 이루어진 n의 배수를 찾는 프로그램을 작성하시오
 * 1로 이루어진 n의 배수 중 가장 작은 수의 자리수를 출력한다.
 *
 * 뭔소린가 하니 배수를 찾는건 나머지가 0 인 값을 찾는 것인데
 * 1로만 이루어진 배수니까
 * 1 % n = 0?
 * 11 % n = 0?
 * 111 % n = 0?
 * ...
 * 이거였음. 가장 작은 수의 자리수 출력하는 거니까 최초로 나머지가 0일 때 값을 리턴 하면 됨
 *
 * -----------------------------------------------------------------
 *
 * [나머지 연산]
 * (A+B) mod M = ( (A mod M) + (B mod M) ) mod M
 * (A×B) mod M = ( (A mod M) × (B mod M) ) mod M
 * 나누기의 경우에는 성립하지 않는다. (Modular Inverse를 구해야 함)
 * 뺄셈의 경우에는 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 다음과 같이 해야 한다.
 * (A-B) mod M = ( (A mod M) ‒ (B mod M) + M) mod M
 *
 *
 *  1 % 7 = 1
 *  11 % 7 = 1 -> (1 * 10 + 1) % 7
 *              -> ((1 % 7) * 10 +1) % 7
 *              -> ( 1 * 10 + 1) % 7
 *              -> 11 % 7 = 4
 *
 *  111 % 7  -> (11 * 10 + 1) % 7
 *           -> ((11 % 7) * 10 + 1) % 7
 *           -> ( 4 * 10 + 1 ) % 7
 *           -> 41 % 7 = 6
 *
 * -> 왜 10 이랑 1은 7로 안나누냐면 굳이 나눌 필요가 없다.
 * -> 10 과 1은 고정값이기 때문
 *
 */
public class Solution {
    @Test
    void solution() {
        int n = 9901;
        System.out.println(find(n));
    }

    private int find(int n) {
        int num = 0;
        int i = 1;
        while(true) {
            //num * (10 % n) + (1 % n); 공식대로 대입해보면 이렇게 대입할 수 있는데 괜히 나머지 연산만 늘어난다.
            //길이가 길어지는 num 자리만 미리 구해놓은 나머지 값을 이용하자.
            num = num * 10 + 1;
            num %= n; // num 에는 n으로 나눈 값의 나머지를 가지고 있게 한다. (이전 결과를 미리 가지고 있는 메모이제이션..같음)
            if(num == 0) {
                return i;
            }
            i++;
        }
    }

}
