package chap04._10844;


import org.junit.jupiter.api.Test;

/**
 *
 * 문제
 * 45656이란 수를 보자.
 *
 * 이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.
 *
 * N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.
 *
 * 입력
 * 첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.
 *
 * 출력
 * 첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.
 *
 * ---
 * 2차원으로 구해야하는 dp 의 경우 점화식 세우는게 아직 서툰거 같다.
 *
 * dp[자리수][앞에 오는 숫자] 로 접근 해줘야 한다.
 * dp[N][0] = 은 모두 dp[N-1][1] 이 된다.
 * 또한 dp[N][9] = dp[N-1][8] 이 된다.
 *
 * N = 1
 * 1,2,3,4,5,6 ...
 * N = 2
 * (10, 12, 21, 23 , 32, 34, 43, 45, 54, 56, 65, 67, 76, 78, 87, 89), 98
 * 1 ~ 8범위는 모두 이전 자리수의 -1, +1 값의 합과 같게되는데, (ex. 2의 경우 1과 3 모두 가능)
 * 0의 경우 이전 자리수의 1밖에 올 수 없다. (아니면 1차이가 넘어감)
 * 9의 경우는 이전 자리수의 8밖에 올 수 없다. (아니면 1차이가 넘어감)
 *
 * dp[n][0] = dp[n-1][1];
 * dp[n][9] = dp[n-1][8];
 * dp[n][1~8] = dp[n-1][j-1] + dp[n-1][j+1];
 *
 *
 */
public class Solution {
    static long[][] dp;
    static long mod = 100000000;
    @Test
    void solution() {
        int n = 2;
        dp = new long[n+1][10];

        for(int i = 1; i<= 9; i++) {
            dp[1][i] = 1;
        }
        System.out.println(sol(n));
    }

    private long sol(int n) {
        int sum = 0;
        for(int i = 2; i<= n; i++) {
            for(int j = 0; j<=9; j++) {
                if(j == 0) {
                    dp[i][0] = dp[i-1][1] % mod;
                }else if(j == 9) {
                    dp[i][9] = dp[i-1][8] % mod;
                }else {
                    dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) % mod;
                }
            }
        }

        for(int i = 0; i<= 9; i++) {
            sum += dp[n][i];
        }
        return sum;
    }

}
